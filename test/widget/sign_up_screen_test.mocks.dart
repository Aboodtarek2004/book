// Manual mock for AuthProvider since build_runner is unavailable.
// Ideally, this would be generated by `mockito`.

import 'package:book/providers/auth_provider.dart';
import 'package:firebase_auth/firebase_auth.dart' as FirebaseAuth;
import 'package:mockito/mockito.dart';
import 'package:flutter/foundation.dart'; // For ChangeNotifier

// It's important that this class 'implements' AuthProvider, not 'extends' it,
// when it's a manual mock being used with Mockito's 'Mock' class.
// However, AuthProvider is a ChangeNotifier. Mocking ChangeNotifiers fully
// can be tricky. For basic method stubbing and verification, this should work.
// If listener notification testing were required, a more complex mock would be needed.

class MockAuthProvider extends Mock implements AuthProvider {
  // --- Manually stubbed methods from AuthProvider ---

  // Keep track of listeners for notifyListeners
  final List<VoidCallback> _listeners = [];

  @override
  bool get isLoggedIn => (super.noSuchMethod(
        Invocation.getter(#isLoggedIn),
        returnValue: false, // Default return value
        returnValueForMissingStub: false,
      ) as bool);

  @override
  bool get isDoctor => (super.noSuchMethod(
        Invocation.getter(#isDoctor),
        returnValue: false, // Default return value
        returnValueForMissingStub: false,
      ) as bool);

  @override
  FirebaseAuth.User? get firebaseUser => (super.noSuchMethod(
        Invocation.getter(#firebaseUser),
        returnValue: null, // Default return value
        returnValueForMissingStub: null,
      ) as FirebaseAuth.User?);

  // UserModel.User? userDetails is also a getter, but we might not need to mock it directly
  // if we control isDoctor and firebaseUser.

  @override
  Stream<FirebaseAuth.User?> get authStateChanges => (super.noSuchMethod(
        Invocation.getter(#authStateChanges),
        returnValue: Stream.value(null), // Default stream
        returnValueForMissingStub: Stream.value(null),
      ) as Stream<FirebaseAuth.User?>);

  @override
  Future<void> signUp(String email, String password, bool isDoctor) {
    return super.noSuchMethod(
      Invocation.method(#signUp, [email, password, isDoctor]),
      returnValue: Future<void>.value(), // Default future
      returnValueForMissingStub: Future<void>.value(),
    ) as Future<void>;
  }

  @override
  Future<void> signIn(String email, String password) {
    return super.noSuchMethod(
      Invocation.method(#signIn, [email, password]),
      returnValue: Future<void>.value(),
      returnValueForMissingStub: Future<void>.value(),
    ) as Future<void>;
  }

  @override
  Future<void> signOut() {
    return super.noSuchMethod(
      Invocation.method(#signOut, []),
      returnValue: Future<void>.value(),
      returnValueForMissingStub: Future<void>.value(),
    ) as Future<void>;
  }

  // --- ChangeNotifier implementation (basic) ---

  @override
  bool get hasListeners => _listeners.isNotEmpty;

  @override
  void addListener(VoidCallback listener) {
    _listeners.add(listener);
    super.noSuchMethod(
      Invocation.method(#addListener, [listener]),
      returnValueForMissingStub: null,
    );
  }

  @override
  void removeListener(VoidCallback listener) {
    _listeners.remove(listener);
    super.noSuchMethod(
      Invocation.method(#removeListener, [listener]),
      returnValueForMissingStub: null,
    );
  }

  @override
  void notifyListeners() {
    for (var listener in _listeners) {
      listener();
    }
    super.noSuchMethod(
      Invocation.method(#notifyListeners, []),
      returnValueForMissingStub: null,
    );
  }

  @override
  void dispose() {
     _listeners.clear();
    super.noSuchMethod(
      Invocation.method(#dispose, []),
      returnValueForMissingStub: null,
    );
  }
}
